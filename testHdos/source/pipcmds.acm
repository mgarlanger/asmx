	STL	'SETFLG - SET FILE(S) FLAGS'
	EJECT
***	SETFLG - SET FILE(S) FLAGS
*
*	SYNTAX:
*
*	SOURCE1,...,SOURCEN/SET[FLAG]:f..
*
*	AT LEAST ONE SOURCE FILE MUST BE SPECIFIED.
*	THE 'C' FLAG IS INVALID HERE.
*	IF '!' IS INCLUDED IN FLAG LIST ONLY SPECIFIED FLAGS WILL BE SET
*		ALL OTHERS WILL BE CLEARED EXCEPT 'C'
*	IF '*' IS INCLUDED IN FLAG LIST ALL FLAGS EXCEPT 'C' WILL BE SET

SETFLG	EQU	*

	CALL	SETUP

*	SET FLAGS ON FILES ONE BY ONE

STFL	LHLD	NAMTLEN
	MOV	A,H
	ORA	L
	JZ	FSUM		END OF LIST

	CALL	OFFF		OPEN FILE & FETCH FLAG

*	CHECK FOR AFFECTED

	LXI	D,D.SET 	OUR DATA
	MOV	A,M
	STA	D.OF		SAVE OLD FLAGS

	LDA	SYSOP
	ANA	A
	JNZ	STF0		SKIP LOCK CHECK IF SYSOP

	MOV	A,M
	ANI	DIF.LOC
	JNZ	STF.C

STF0	LDAX	D
	ANI	DIF.CNT 	'Z' SET IF '!' GIVEN
	LDAX	D		OUR DATA
	JZ	STF1		JUST INCLUDE FLAGS
	ANI	11101111B	CAN'T SET 'C'
	MOV	B,A
	MVI	A,11101111B
	ANA	M
	CMP	B		SEE IF ALREADY SET
	JE	STF.C		CLEAR CHANNEL & SKIP COUNT
	MOV	A,B
	JMP	STF.S		SET, CLOSE, COUNT & PRINT FILE

STF1	ANA	M
	XCHG
	CMP	M		SEE IF ALREADY SET
	XCHG
	JE	STF.C		CLEAR CHANNEL & SKIP COUNT
	LDAX	D
	ORA	M		INCLUDE OUR DATA
	JMP	STF.S		SET, CLOSE, COUNT & PRINT FILE

STF.C	XRA	A		CN.SOU = 0
	SCALL	.CLEAR
	JC	NAMERR
	JMP	STFX

STF.S	CALL	SCCP		SET, CLOSE, COUNT & PRINT ONLY IF AFFECTED

STFX	CALL	REN		REMOVE ENTRY FROM NAMTAB
	JMP	STFL		GET NEXT FILE
	STL	'CLRFLG - CLEAR FILE(S) FLAGS'
	EJECT
***	CLRFLG - CLEAR FILE(S) FLAGS
*
*	SYNTAX:
*
*	SOURCE1,...,SOURCEN/CLR[FLAG][:f..]
*
*	AT LEAST ONE SOURCE FILE MUST BE SPECIFIED.
*	THE 'C' FLAG IS INVALID HERE.
*	IF NO FLAG LIST IS GIVEN (OR '*' IS INCLUDED IN LIST) ALL FLAGS
*		ARE CLEARED EXCEPT 'C'.
*	IF '@' IS INCLUDED IN FLAG LIST THE ACCESS DATE AND COUNT ARE CLEARED

CLRFLG	EQU	*

	CALL	SETUP

*	CLEAR FLAGS ON FILES ONE BY ONE

CLFL	LHLD	NAMTLEN
	MOV	A,H
	ORA	L
	JZ	FSUM		END OF LIST

	CALL	OFFF		OPEN FILE & FETCH FLAG

*	CHECK FOR AFFECTED

	LXI	D,D.SET 	OUR DATA
	MOV	A,M
	STA	D.OF		SAVE OLD FLAGS

	ANI	DIF.LOC 	IS FILE LOCKED
	JZ	CLF0		NO, DON'T WORRY ABOUT SYSOP

	XCHG			(HL) => OUR DATA, (DE) => OLD FLAGS
	LDA	SYSOP
	ANA	A
	MVI	A,377Q		MASK FOR EVERYTHING
	JNZ	CLFA
	MVI	A,DIF.CNT	MASK FOR ONLY '@'
CLFA	ANA	M
	MOV	M,A
	XCHG			(DE) => OUR DATA, (HL) => OLD FLAGS

CLF0	LDAX	D
	ANI	DIF.CNT 	'@'?
	JNZ	CLF2		YES

CLF1	LDAX	D
	ANI	11101111B	CAN'T CLEAR 'C'
	MOV	C,A
	CMA			FORM MASK
	MOV	B,A
	MOV	A,M
	ANA	C		SEE IF ALREADY CLEAR
	JZ	CLF.C		CLEAR CHANNEL & SKIP COUNT
	MOV	A,M
	ANA	B
	JMP	CLF.S		SET, CLOSE, COUNT & PRINT FILE

CLF.C	XRA	A		CN.SOU = 0
	SCALL	.CLEAR
	JC	NAMERR
	JMP	CLFX

CLF2	DCX	H		POINT TO A/C
	MOV	A,M
	INX	H
	ANA	A		SEE IF CLEAR
	JZ	CLF1		YES, FILE POSSIBLY NOT AFFECTED
	PUSH	H
	DCX	H
	MVI	M,0		CLEAR A/C
	LXI	B,DIR.ACD-DIR.NOA
	DAD	B
	MVI	M,0
	INX	H
	MVI	M,0		CLEAR ACC. DATE
	POP	H
	LDAX	D
	ANI	11101111B	CLEAR '@' FROM DATA
	CMA
	ANA	M		CLEAR ANY AFFECTED FLAGS

*	EVEN IF NO FLAGS WERE AFFECTED THE FILE IS AFFECTED BECAUSE OF
*	CLEARING THE A/C & ACC. DATE, SO COUNT IT

CLF.S	CALL	SCCP		SET, CLOSE, COUNT & PRINT ONLY IF AFFECTED

CLFX	CALL	REN		REMOVE ENTRY FROM NAMTAB
	JMP	CLFL		GET NEXT FILE
	STL	'PUTUSR - PUT FILE(S) IN USER AREAS'
	EJECT
***	PUTUSR - PUT FILE(S) IN USER AREAS
*
*	SYNTAX:
*
*	SOURCE1,...,SOURCEN/PUT[USER]:u..
*
*	AT LEAST ONE SOURCE FILE MUST BE SPECIFIED.
*	THE 0 USER AREA IS INVALID HERE.
*	IF '!' IS INCLUDED IN USER LIST ONLY SPECIFIED USERS & 0 WILL
*		BE SET, ALL OTHERS WILL BE CLEARED.
*	IF '*' IS INCLUDED IN USER LIST ALL USER AREAS WILL BE SET

	IF	USER
PUTUSR	EQU	*

	CALL	SETUP

*	PUT FILES IN USER AREAS ONE BY ONE

PTUL	LHLD	NAMTLEN
	MOV	A,H
	ORA	L
	JZ	FSUM		END OF LIST

	CALL	OFFF		OPEN FILE & FETCH FLAG
	ERRNZ	DIR.USR-DIR.FLG-1
	INX	H		BUMP TO USER BYTE

*	CHECK FOR AFFECTED

	LXI	D,D.SET 	OUR DATA
	LDAX	D
	ANI	10000000B	'Z' SET IF '!' GIVEN
	LDAX	D		OUR DATA
	JZ	PTU1		JUST INCLUDE FLAGS
	ANI	01111111B	CAN'T SET 0
	MOV	B,A
	MVI	A,177Q
	ANA	M
	CMP	B		SEE IF ALREADY SET
	JE	PTU.C		CLEAR CHANNEL & SKIP COUNT
	MOV	A,B
	ORI	200Q		FORCE USER 0
	JMP	PTU.S		SET, CLOSE, COUNT & PRINT FILE

PTU1	ANA	M
	XCHG
	CMP	M		SEE IF ALREADY SET
	XCHG
	JE	PTU.C		CLEAR CHANNEL & SKIP COUNT
	LDAX	D
	ORA	M		INCLUDE OUR DATA
	ORI	200Q		FORCE USER 0
	JMP	PTU.S		SET, CLOSE, COUNT & PRINT FILE

PTU.C	XRA	A		CN.SOU = 0
	SCALL	.CLEAR
	JC	NAMERR
	JMP	PTUX

PTU.S	CALL	SCCP		SET, CLOSE, COUNT & PRINT ONLY IF AFFECTED

PTUX	CALL	REN		REMOVE ENTRY FROM NAMTAB
	JMP	PTUL		GET NEXT FILE
	ENDIF
	STL	'REMUSR - REMOVE FILE(S) FROM USER AREAS'
	EJECT
***	REMUSR - REMOVE FILE(S) FROM USER AREAS
*
*	SYNTAX:
*
*	SOURCE1,...,SOURCEN/REM[USER][:u..]
*
*	AT LEAST ONE SOURCE FILE MUST BE SPECIFIED.
*	THE 0 USER AREA IS INVALID HERE.
*	IF NO USER LIST IS GIVEN (OR '*' IS INCLUDED IN LIST) 
*		ALL USER AREAS EXCEPT 0 ARE CLEARED.

	IF	USER
REMUSR	EQU	*

	CALL	SETUP

*	REMOVE FILES FROM USER AREAS ONE BY ONE

RMUL	LHLD	NAMTLEN
	MOV	A,H
	ORA	L
	JZ	FSUM		END OF LIST

	CALL	OFFF		OPEN FILE & FETCH FLAG
	ERRNZ	DIR.USR-DIR.FLG-1
	INX	H		BUMP TO USER BYTE

*	CHECK FOR AFFECTED

	LXI	D,D.SET 	OUR DATA
	LDAX	D
	ANI	01111111B	CAN'T CLEAR USER 0
	MOV	C,A
	CMA			FORM MASK
	MOV	B,A
	MOV	A,M
	ANA	C		SEE IF ALREADY CLEAR
	JZ	RMU.C		CLEAR CHANNEL & SKIP COUNT
	MOV	A,M
	ANA	B
	ORI	200Q		FORCE USER 0
	JMP	RMU.S		SET, CLOSE, COUNT & PRINT FILE

RMU.C	XRA	A		CN.SOU = 0
	SCALL	.CLEAR
	JC	NAMERR
	JMP	RMUX

RMU.S	CALL	SCCP		SET, CLOSE, COUNT & PRINT ONLY IF AFFECTED

RMUX	CALL	REN		REMOVE ENTRY FROM NAMTAB
	JMP	RMUL		GET NEXT FILE
	ENDIF
	STL	'ROUTINES FOR SETFLAG,CLRFLAG,PUTUSER,REMUSER'
	EJECT
**	SETUP - SETUP ROUTINE FOR SET,CLR,PUT,REM & PARTIALLY FOR DEL

*	ZERO COUNT,CHECK FOR DEST,BUILD SOURCE LIST

SETUP	XRA	A
	STA	COPYC		CLEAR FILE COUNT

	CALL	CHKLN		MUST HAVE ONLY SOURCE FILE(S)
	JZ	ERROR		NO SOURCE FILE

	LDA	COMAND
	CPI	I.DEL
	RE			IF CALLED FROM /DELETE

	XRA	A		ALLOW *.*
	CALL	BSL		BUILD SOURCE FILE LIST
	JC	ERROR		NO GOOD
	RET
	SPACE	3,10
**	CHKLN - CHECK FOR TARGET AND SOURCE FILES

CHKLN	CALL	CTS		CHECK FOR TARGET FILE SPECIFICATION
	JNZ	ERROR		TARGET FILE SPECIFICATION ILLEGAL
	LXI	H,LINE
	CALL	$SOB		SKIP OVER ALL THE BLANKS ($DRS TURNS SWITCHES
	ANA	A		 TO BLANKS)
	MVI	A,PEC.SFI	SOURCE FILE ILLEGAL
	RET			'Z' SET IF NO SOURCE FILE FOUND
	SPACE	3,10
**	FSUM - FILE SUMMARY FOR SETFLAG,CLRFLAG,PUTUSER,REMUSER

FSUM	CALL	$MOVEL
	DW	8,AFFN,FSUMT

FSUM.	LDA	COPYC		COUNT
	MVI	B,0
	MOV	C,A
	LDA	SUPRES
	ANA	A
	RNZ			SUPRESS TRAILING MESSAGE
	MVI	A,3
	LXI	H,FNUM
	CALL	$UDDS
	CALL	$GNL
	CALL	$TYPTX
	DB	NL
FNUM	DB	'XXX Files '
FSUMT	DB	'Affected',ENL
	RET

AFFN	DB	'Affected'
	SPACE 3,10
**	CFU - KLUDGE FILE TO UPDATE STATUS
*
*	ENTRY AT CFU WILL SET UPDATE STATUS
*
*	ENTRY	FILE OPEN ON CN.SOU
*	EXIT	NONE
*	USES	A,F,D,E,H,L

CFU	LHLD	S.CFWA
	ERRNZ	CN.SOU
	CALL	$HLIHL		HL => CHANNEL 0
	LXI	D,IOC.FLG
	DAD	D		HL => I/O FLAG BYTE
	MVI	A,FT.OW+FT.OU	UPDATE STATUS
	ORA	M
	MOV	M,A		CHANGE STATUS
	RET
	SPACE	3,10
**	OFFF - OPEN FILE & FETCH FLAG

*	OPEN FILE FOR READ

OFFF	LXI	H,NAMTAB
OFFF.	LXI	D,SDDA		DEFAULT BLOCK
	XRA	A		CN.SOU = 0
	SCALL	.OPENR		OPEN FOR READ
	JC	NAMERR

*	FETCH FLAG BYTE

	LHLD	S.CFWA
	ERRNZ	CN.SOU
	CALL	$HLIHL
	LXI	D,IOC.DIR+DIR.FLG	OFFSET TO FLAG BYTE
	DAD	D		HL => FILE FLAGS
	RET
	SPACE	3,10
**	SCCP

*	SET FLAGS, CLOSE FILE, COUNT & PRINT NAME

SCCP	STA	D.NF		SAVE FOR PRINTING LATER

	CALL	FCP.

SCCP.	LXI	H,COPYC
	INR	M		COUNT FILE
	LXI	H,NAMTAB
	XRA	A		PRINT FILE NAME REGARDLESS SO ...
	STA	COPYA		FLAG AS WILD CARD TO FOOL XCOPY1
	CALL	XCOPY1		PRINT FILE NAME AS IN COPY

	LDA	SUPRES
	ANA	A
	RNZ
	ERRNZ	I.CLR-I.SET-1
	LDA	COMAND
	CPI	I.SET
	RC			LESS THAN /SET
	CPI	I.CLR+1
	RNC			GREATER THAN /CLR
	CALL	$TYPTX
	DB	TAB,'Old Flags:',' '+200Q
	MVI	A,0
D.OF	EQU	*-1
	LXI	H,SCCPO
	LXI	D,PFIB
	CALL	PFI30
	CALL	$TYPTX
SCCPO	DB	'SLWCABDU'
	DB	TAB,'New Flags:',' '+200Q
	MVI	A,0
D.NF	EQU	*-1		NEW FLAG DATA
	LXI	H,SCCPF
	LXI	D,PFIB
	CALL	PFI30
	CALL	$TYPTX
SCCPF	DB	'SLWCABDU',200Q
	RET
	STL	'DELETE - PROCESS DELETE COMMAND.'
	EJECT
***	DELETE - PROCESS DELETE COMMAND.
*
*	SYNTAX:
*
*	SOURCE1,...,SOURCEN/DEL[ETE][/FOR]
*
*	AT LEAST ONE SOURCE FILE MUST BE SPECIFIED.
*	IF *.* IS SPECIFIED, DELETE ASKS, 
*		DELETE ALL ?!? ARE YOU SURE?

DELETE	EQU	*

	CALL	SETUP

*	NO TARGET FILE SPECIFIED

DEL2	LDA	QUERY		CHECK FOR *.* ONLY IF /Q NOT ASKED FOR
	XRI	1		(A)=0 IF /Q, (A)=1 IF NOT /Q
	CALL	BSL		BUILD SOURCE FILE LIST
	JC	ERROR		NO GOOD

*	DELETE FILES ONE BY ONE

DEL3	LHLD	NAMTLEN
	MOV	A,H
	ORA	L
	JZ	DEL4		END OF LIST
	CALL	SCCP.		COUNT & PRINT NAME
	PUSH	H
	SCALL	.DELETE 	REMOVE IT
	JC	DEL5		ERROR ON DELETE
	POP	H
DEL3.	CALL	REN		REMOVE ENTRY FROM NAMTAB
	JMP	DEL3		GET NEXT FILE

DEL4	CALL	$MOVEL
	DW	8,DELN,FSUMT
	JMP	FSUM.

DEL5	CALL	FORCHK
	POP	H
	SCALL	.DELETE
	JC	NAMERR
	JMP	DEL3.

DELN	DB	'Deleted',32
	STL	'RENAME - PROCESS RENAME COMMAND'
	EJECT
***	RENAME - RENAME FILES.
*
*	SYNTAX:
*
*	DEST = SOURCE1,...,SOURCEN/R[ENAME]
*
*	RENAME IS PROCESSED IN A MANNER SIMILAR TO COPY, EXCEPT THAT THE
*	FILE IS RENAMED, RATHER THAN COPIED.

RENAME	EQU	*

	XRA	A
	STA	COPYC		CLEAR FILE COUNT

	CALL	DDF		DECODE DESTINATION FILE
	STA	COPYA		SAVE WILD CARD FLAG
	JC	ERROR

	CALL	$MOVEL		SET DEFAULT DEVICE
	DW	3,PIO.DEV,DEFALT

	XRA	A		ALLOW *.*
	CALL	BSL		BUILD SOURCEFILE LIST
	JC	ERROR

*	DO MULTIPLE RENAMES

REN1	LXI	B,DESTFB+FB.NAM	(BC) = WILDCARDED TARGET NAME
	LXI	D,NAMTAB	(DE) = NORMAL SOURCE NAME
	LXI	H,RENA		(HL) = BUFFER FOR RESULT NAME
	PUSH	B		SAVE #DESTFB+FB.NAM
	PUSH	D		SAVE #NAMTAB
	CALL	MWN		MERGE WILDCARD NAME
	POP	D		(DE) = #NAMTAB
	POP	H		(HL) = #DESTFB+FB.NAM

*	SEE IF SOURCE AND DEST FILE ON SAME DEVICE

	PUSH	D		SAVE #NAMTAB (SOURCE NAME)
	MVI	C,3
	CALL	$COMP		COMPARE DEVICES
	MVI	A,PEC.DNC	DEVICES NOT CONSISTANT
	JNE	ERROR

*	SEE IF TARGET ALREADY EXISTS

	LXI	H,RENA
	XRA	A		CN.SOU = 0
	SCALL	.OPENR
	LXI	H,RENA-FB.NAM
	JC	REN2		HAVE AN ERROR (AS WE SHOULD)
	MVI	A,EC.FAP	FILE ALREADY PRESENT
	JMP	$FERROR		ALREADY THERE

REN2	CPI	EC.FNF		MUST BE NOT FOUND
	JNE	$FERROR		OTHER ERROR
	POP	H		(HL) = SOURCE NAME
	CALL	XRENAM		PRINT OLD => NEW NAMES
	LXI	B,RENA		(BC) = NEW (TARGET) NAME
	PUSH	B
	PUSH	H
	SCALL	.RENAME 	RENAME IT
	JC	REN3		ERROR ON RENAME
	POP	H
	POP	B
REN2.	LXI	H,COPYC
	INR	M		COUNT FILE

*	REMOVE NAME FROM NAMTAB

	CALL	REN		REMOVE ENTRY FROM NAMTAB
	LHLD	NAMTLEN
	MOV	A,H
	ORA	L
	JNZ	REN1

*	REPORT

	CALL	$MOVEL
	DW	8,RENN,FSUMT
	JMP	FSUM.

REN3	POP	H
	PUSH	H
	CALL	FORCHK
	POP	H
	POP	B
	SCALL	.RENAME
	JC	NAMERR
	LDA	KEEP
	ORA	A
	JZ	REN2.
	LXI	H,RENA
	CALL	OFFF.
	LDA	D.SET
	CALL	FCP.
	JMP	REN2.

RENN	DB	'Renamed',32

**	RENAME command extension by Bill Parrott

XRENAM	LDA	SUPRES
	ANA	A
	RNZ
	LDA	COPYA
	ANA	A
	RNZ
	PUSH	H
	CALL	$CRLF
	CALL	CAD
	CALL	TFNS
	CALL	$TYPTX
	DB	' ==>',' '+200Q
	LXI	H,RENA
	CALL	CAD
	CALL	TFNS
	POP	H
	RET
	STL	'FORCHK - CHECK FORCE SWITCH'
	EJECT
***	FORCHK - CHECK FORCE SWITCH
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	A,F,D,E,H,L

FORCHK	PUSH	PSW		SAVE ERROR CODE

	LDA	FORCE
	ORA	A
	JZ	FCE		NOT FORCED

	LDA	SYSOP
	ANA	A
	JNZ	FORCKC		SKIP LOCK CHECK IF SYSOP

	POP	PSW
	CPI	EC.FL		FILE LOCKED
	JE	NAMERR
	PUSH	PSW		ANTICIPATE NEXT POP

FORCKC	POP	PSW		RESTORE ERROR CODE
	CPI	EC.WPV		WRITE PROTECT VIOLATION
	JE	FCP
	CPI	EC.LAD		LOCKED AGAINST DELETE
	JNE	NAMERR

FCP	CALL	OFFF		PROCEED, OPEN & FETCH FLAG
	MOV	A,M
	STA	D.SET		SAVE FOR /KEEP
	XRA	A		WIPE OUT ALL FLAGS
FCP.	MOV	M,A		SET NEW FLAGS
	CALL	CFU		KLUDGE FOR UPDATE
	XRA	A		CN.SOU
	SCALL	.CLOSE
	RNC
	PUSH	PSW		ANTICIPATE NEXT POP

FCE	POP	PSW		EXIT WITH ERROR
	JMP	NAMERR
	STL	'CHECK - CHECKSUM OF A FILE'
	EJECT
***	CHECK - CHECKSUM OF A FILE
*
*	SYNTAX:
*
*	DEST=SOURCE1,...,SOURCEN/CRC
*
*	'DEST' IS THE DESTINATION FILE DESIGNATOR. IF NULL
*	(IN WHICH CASE THE '=' MAY BE OMITTED) IT DEFAULTS TO
*
*		TT:PIPDEST.JGL
*
*	WILDCARDS ARE NOT PERMITTED IN 'DEST'.
*
*	THE 'SOURCE' FIELDS ARE THE SOURCE FILE DESIGNATORS. WILDCARDS
*	MAY BE USED FOR FILE NAME AND EXTENSION.
*
*	'DEST' WILL CONTAIN A LIST OF FILE NAMES AND CRC'S IN THE
*	FOLLOWING FORMAT:
*
*		Name	.Ext	CRC Dec  CRC Oct   CRC Hex	DD-MMM-YY
*
*		XXXX	.XXX	NNNNN	 OOO.OOO   HHHH

CHECK	EQU	*

	CALL	DDF		DECODE DEST FILE
	JC	ERROR
	ANA	A
	MVI	A,PEC.IUW	ASSUME ILLEGAL WILDCARD
	JZ	ERROR
	XRA	A		ALLOW *.*
	STA	COPYCT		RESET COPY COUNTER
	CALL	BSL		BUILD SOURCE FILE LIST
	JC	ERROR

*	HAVE DEST & SOURCE FILE NAMES, OPEN DEST FILE & WRITE HEADER

	LXI	D,CHEA		DEFALT
	LXI	H,DESTFB	FILE NAME
	PUSH	H
	CALL	$FOPEW		OPEN FOR WRITE
	CALL	$MOVEL		MOVE IN CURRENT DATE
	DW	9,S.DATE,CHEBD
	POP	H

	LDA	SUPRES
	CPI	2
	JNC	CHE0		NO HEADER WANTED

	LXI	B,CHEBL 	(BC) = LEN
	LXI	D,CHEB		(DE) = DATA FWA
	CALL	$FWRIB		WRITE HEADER

CHE0	CALL	SDD		RESET DEFAULT DEFAULTS
	CALL	HMSF		HOW MANY SOURCE FILES

*	PROCESS CHECKSUM FUNCTION

CHE1	LHLD	NAMTLEN
	MOV	A,H
	ORA	L
	JZ	CHE6		NO MORE FILES TO DO

	LDA	H19FLG
	ANA	A
	JZ	CHE1.		NOT H19 SO SKIP THE FANCY STUFF

	LDA	SUPRES
	CPI	3
	JNC	CHE1.		NO STATUS LINE

	CALL	SHOW25
	CALL	$TYPTX
	DB	'CRC''in','g'+200Q
	CALL	SHOW25.

CHE1.	LXI	H,NAMTAB	(HL) = NAME ADDRESS
	CALL	CKSUM		DO CRC CHECKSUM
	PUSH	H		SAVE IT

	CALL	SHOW25X 	Clean up line 25 if H19

	LXI	H,NAMTAB	POINT TO FILE NAME
	LXI	D,DEFALT
	CALL	CAD
	LXI	H,PFIA		LINE BUFFER
	LXI	D,PIO.DIR+DIR.NAM
	MVI	C,8
	CALL	PFI20
	JZ	CHE5
	MVI	M,TAB
	INX	H
CHE5	MVI	M,'.'
	INX	H
	MVI	C,3
	CALL	PFI20
	MVI	M,TAB
	INX	H
	POP	B		(BC) = CRC
	PUSH	B
	MVI	A,5
	CALL	$UDD
	CALL	PFI40
	CALL	PFI40
	POP	B
	PUSH	B
	CALL	$UOW.
	CALL	PFI40
	MVI	M,' '
	INX	H
	POP	B
	CALL	$UHW
	MVI	M,NL
	INX	H
	LXI	D,-PFIA
	DAD	D
	MOV	B,H
	MOV	C,L		(BC) = LEN
	LXI	D,PFIA		(DE) = LINE FWA
	LXI	H,DESTFB
	CALL	$FWRIB		WRITE LINE TO DEST
	CALL	REN		REMOVE ENTRY FROM NAMTAB
	JMP	CHE1		GET NEXT FILE

*	FILE CHECKSUMS COMPLETE, CLOSE DEST

CHE6	LXI	H,DESTFB
	CALL	$FCLO

	CALL	$MOVEL
	DW	8,CHEN,FSUMT
	JMP	FSUM.

*	CKSUM - DO CRC CHECKSUM
*
*	ENTRY	HL => FILE NAME
*	EXIT	HL = CRCSUM
*	USES	ALL

CKSUM	XRA	A		(A) = CN.SOU
	SCALL	.OPENR
	JC	NAMERR
	LXI	H,0
	SHLD	.CRCSUM 	ZERO CHECKSUM

	CALL	EBM		EXPAND BUFFER TO MAX
CHE2	LHLD	BUFSIZ
	MOV	B,H
	MOV	C,L		(BC) = LENGTH OF BUFFER
	LHLD	BUFPTR
	XCHG			(DE) = BUFFER FWA
	XRA	A		(A) = CN.SOU
	SCALL	.READ
	PUSH	PSW
	JNC	CHE3		FULL BUFFER
	CPI	EC.EOF
	JE	CHE3		IF EOF
	POP	PSW		RESTORE ERROR CODE
	JMP	NAMERR

CHE3	LDA	BUFSIZ+1	A = # OF SECTORS IN BUFFER
	SUB	B
	MOV	B,A		B = SECTORS READ
	MVI	C,0
	LHLD	.CRCSUM
	XCHG			DE = PREVIOUS CRCSUM (IF ANY)
	LHLD	BUFPTR
	SCALL	.CRC16
	XCHG			HL = UPDATED CRCSUM
	SHLD	.CRCSUM
	POP	PSW		STATUS FROM READ
	JNC	CHE2		NOT EOF, GET NEXT BUNCH
	CALL	SBE		SHRINK BUFFER TO MIN

	XRA	A		(A) = CN.SOU
	SCALL	.CLOSE
	LHLD	.CRCSUM 	GET CRC
	RET

CHEN	DB	'CRC''ed',32,32

CHEA	DB	'SY0CRC'

CHEB	DB	NL,'Name',TAB,'.Ext',TAB,'CRC Dec',32,32,'CRC Oct'
	DB	32,32,32,'CRC Hex',TAB
CHEBD	DB	'WGP...RLM'	DATE
	DB	NL,NL
CHEBL	EQU	*-CHEB
	STL	'MOUNT - DISMOUNT - RESET'
	EJECT
***	MOUNT	-  MOUNT A NEW DISK
*
*	MOUNT MOUNTS A NEW DISK ON THE SPECIFIED UNIT OF THE SELECTED
*	DEVICE.
*
*	DEV:/MOU[NT]

MOUNT	EQU	*
	MVI	A,.MOUNT
	JMP	MDR.		MOUNT/DISMOUNT/RESET
	SPACE	3,10
***	DISMOU	-  DISMOUNT CURRENT DISK
*
*	DISMOU DISMOUNTS THE CURRENT DISK ON THE SPECIFIED UNIT OF THE
*	SELECTED DEVICE.
*
*	DEV:/DIS[MOUNT]

DISMOU	EQU	*
	MVI	A,.DMOUN
	JMP	MDR.		MOUNT/DISMOUNT/RESET
	SPACE	3,10
***	RESET	-  RESET THE CURRENT DISK
*
*	RESET RESETS THE SPECIFIED UNIT OF THE SELECTED DEVICE BY ISSUING
*	THE HDOS RESET CALL, WHICH IN TURN ISSUES A DISMOUNT AND MOUNT
*	ASKING THE USER TO OPEN THE DRIVE IN BETWEEN THE TWO.
*
*	DEV:/RES[ET]

RESET	EQU	*
	MVI	A,.RESET
*	JMP	MDR.		MOUNT/DISMOUNT/RESET
	ERRNZ	*-MDR.
	SPACE	4,10
**	MDR.	-  MOUNT/DISMOUNT/RESET
*
*	MDR. PERFORMS THE SIMILAR FUNCTIONS OF MOUNT, DISMOUNT, AND RESET.
*
*
*	ENTRY	(A)	=  SYSCALL CODE FOR OPERATION TO BE PERFORMED
*
*	EXIT	IF  NO ERROR
*		    TO CALLER
*		  ELSE
*		    TO ERROR
*
*	USES	ALL

MDR.	STA	MDRA		STORE SYSCALL VALUE
	CALL	CTS		CHECK FOR TARGET FILE SPECIFICATION
	JNZ	ERROR		THERE WAS A TARGET FILE
	LXI	H,LINE
	CALL	$DTB		DELETE TRAILING BLANKS
	CPI	1		(A) = LINE LENGTH INCLUDING <00> BYTE
	MVI	A,PEC.DF	DEVICE FORMAT ERROR
	JZ	ERROR		NULL DEVICE IS ILLEGAL, ONLY BYTE IS NULL
	SCALL	0
MDRA	EQU	*-1		SYSCALL VALUE
	JC	ERROR
	RET
	STL	'VERSN - PIP VERSION INFORMATION'
	EJECT
***	VERSN - PIP VERSION INFORMATION
*
*	/VERS[ION]
*	/ID
*
*	PRINT PIP VERSION INFORMATION TO THE SCREEN.

VERSN	EQU	*

	CALL	CHKLN		CHECK FOR TARGET & SOURCE FILE SPECS
	JNZ	ERROR		ONLY ALLOW SWITCH ON LINE

	CALL	$TYPTX
	DB	NL,'PIP/plus',32,32,32,32,'Version: '
	DB	VERS/16+'0','.',VERS&0FH+'0'
	DB	' Rev. ','A'+CUSTOM,' ','['+200Q

	LDA	SYSOP
	ANA	A
	JZ	VERSN0

	CALL	$TYPTX
	DB	' Syso','p'+200Q

VERSN0	LDA	H19FLG
	ANA	A
	JZ	VERSN1

	CALL	$TYPTX
	DB	' H1','9'+200Q

VERSN1	CALL	$TYPTX
	IF	USER
	DB	' User'
	ENDIF
	DB	' ] As of '
	DATE
	DB	ENL
	RET

*	/ID Entry Point

VERSNX	CALL	VERSN			; Show version info
	LXI	B,PIP
	LXI	H,VERSV0
	CALL	$UOW.
	LXI	B,MEML-1
	LXI	H,VERSV1
	CALL	$UOW.
	LHLD	BUFPTR
	MOV	B,H
	MOV	C,L
	LXI	H,VERSV2
	CALL	$UOW.
	CALL	EBM
	LHLD	BUFSIZ
	MVI	B,0
	MOV	C,H
	MVI	A,3
	LXI	H,VERSV3
	CALL	$UDDN

	CALL	$TYPTX
	DB	'FWA = '
VERSV0	DB	'000.000',TAB,'LWA = '
VERSV1	DB	'000.000',TAB,'Buffer = '
VERSV2	DB	'000.000','   Size = '
VERSV3	DB	'nnn sectors',ENL
	JMP	SBE			; shrink buffer and return
	STL	'??? - PRINT PIP HELP FILE'
	EJECT
***	??? - PRINT PIP HELP FILE
*
*	/?[??]
*
*	PRINT PIP HELP FILE TO THE SCREEN.

HELP	EQU	*

	CALL	CHKLN		CHECK FOR TARGET & SOURCE FILE SPECS
	JNZ	ERROR		ONLY ALLOW SWITCH ON LINE

	CALL	$MOVEL		PASS 'HELP' TO BUFFER
	DW	HELPCL,HELPC,LINE

	JMP	PIP2		MAKE THIS OUR COMMAND

HELPC	DB	'HELP/SU/SU/SU',0
HELPCL	EQU	*-HELPC
	STL	'ERROR PROCESSING'
	EJECT
**	ERROR PROCESSING ROUTINES
	SPACE	3,10
***	NAMERR - FILE TYPE ERROR, OCCURRED ON FILE WHOSE NAME
*	IS NEXT UP IN NAMTAB.
*
*	PROCESS VIA $FERROR

NAMERR	LXI	H,NAMTAB-FB.NAM
	JMP	$FERROR
	SPACE	4,10
**	INTERNAL ERRORS. SHOULD NOT OCCUR.

IERR1	MVI	A,'1'
	DB	1		FAKE LXI B,
IERR2	MVI	A,'2'
	DB	1		FAKE LXI B,
IERR3	MVI	A,'3'

INTERR	STA	IEN		SAVE CODE
	CALL	$TYPTX
	DB	BELL,NL,'PIP CRASH '
IEN	DB	'n',ENL

	LDA	SYSOP
	ANA	A
	CZ	S.FASER 	BYE, BYE!

ABORT	MVI	A,1
	SCALL	.EXIT		ABORT
	SPACE	4,10
**	ERROR - GENERAL AND SYNTAX ERRORS NOT DIRECTLY ASSOCIATED
*	WITH A VALID FILE NAME.

ERROR	PUSH	PSW		SAVE CODE
	CALL	$TYPTX
	DB	NL,'ERROR -',' '+200Q
	POP	PSW
	ANA	A
	JM	ERROR1		IS PRODUCT ERROR
	MVI	H,BELL		USE BELL AS MESSAGE TRAIL CHAR
	SCALL	.ERROR		LOOK UP SYSTEM ERROR
	JMP	RESTART

*	IS PRODUCT ERROR

ERROR1	LXI	H,ERRORA
ERROR2	CMP	M
	INX	H
	JNE	ERROR2		FIND ERROR MESSAGE
	SCALL	.PRINT		PRINT MESSAGE
	CALL	$TYPTX
	DB	BELL+200Q
	JMP	RESTART

ERRORA	DS	0		ERROR MESSAGES
	DB	PEC.DF,'Device Format Erro','r'+200Q
	DB	PEC.DNC,'All Files Must Reside on Same Devic','e'+200Q
	DB	PEC.TFI,'Illegal Destination File Spec','.'+200Q
	DB	PEC.CS,'Contradictory Switche','s'+200Q
	DB	PEC.IUW,'Illegal Use of Wildcar','d'+200Q
	DB	PEC.IDF,'Illegal Destination File Forma','t'+200Q
	DB	PEC.SFI,'Illegal Source File Spec','.'+200Q
	DB	PEC.ISS,'Illegal Subswitc','h'+200Q
	DB	PEC.MSS,'Missing Subswitc','h'+200Q
