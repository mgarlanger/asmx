	STL	'SUBROUTINES'
	EJECT
**	AEN - ADD ENTRY TO 'NAMTAB'
*
*	AEN EXPANDS THE FILE INFO IN PIO.XXX INTO A FILE DESCRIPTOR
*	AND ENTERS IT IN THE NAMTAB TABLE.
*
*	ENTRY	NONE
*	EXIT	'C' SET IF WILDCARD
*	USES	ALL

AEN	LXI	H,AENA
	CALL	CDA		CONVERT DIRECTORY FORMAT TO ASCII FORMAT
	SUI	1		'C' SET IF WILDCARD
	PUSH	PSW		SAVE FLAG
	JC	AEN1		Ignore Query for wild card names
	CALL	CQF		Check Query Flag
	JNZ	AEN2		Don't copy this file
AEN1	LHLD	NAMTLEN
	LXI	B,FB.NAML
	DAD	B		INCREASE SIZE
	SHLD	NAMTLEN
	XCHG			(DE) = NEW LENGTH
	LHLD	NAMTMAX
	MOV	A,L		SEE IF WILL OVERFLOW
	SUB	E
	MOV	A,H
	SBB	D
	CC	INA		INCREASE NAMTAB ALLOCATION
	LXI	H,NAMTAB-FB.NAML
	DAD	D		(HL) = *TO* ADDRESS
	LXI	D,AENA		(DE) = *FROM* ADDRESS
	CALL	$MOVE		MOVE ENTRY IN
AEN2	POP	PSW		(PSW) = WILDCARD FLAG
	RET
	SPACE	4,10
**	BSL - BUILD SOURCE FILE LIST.
*
*	BSL CRACKS THE LIST OF THE SOURCE FILES FROM THE COMMAND LINE AND
*	BUILDS THEM INTO THE NAMTAB MANAGED TABLE.
*	WILD CARDS ENCOUNTERED ARE EXPANDED.
*
*	ENTRY	(A) <> 0 IF TO ASK ABOUT '*.*' USE
*	EXIT	'C' CLEAR IF OK
*		'C' SET IF ERROR
*		 (A) = CODE
*	USES	ALL

BSL	STA	BSLA		SAVE ASK FLAG
	CALL	LSN		LOCATE SOURCE NAME

*	GO THROUGH SOURCE LIST CRACKING NAMES

BSL1	MOV	A,M
	ANA	A
	JZ	BSL3		ALL DONE
	LXI	D,DEFALT
	CALL	CAD		CONVERT ASCII NAME TO DIRECTORY FORMAT
	RC			ERROR
	CALL	SND		SET NEW DEFAULTS
	PUSH	H		SAVE LINE ADDRESS
	LDA	BSLA
	ANA	A
	CNZ	CCW		CHECK FOR COMPLETE WILDCARD (*.*)
	JC	RESTART 	USER CHICKENED OUT
	CALL	EWS		EXPAND WILDCARD SPECIFICATION
BSL2	POP	H		RESTORE LINE ADDRESS
	RC			USER REFUSED *.*
	CALL	SFS		SKIP FILE SEPERATOR (BLANKS AND/OR COMMA)
	JMP	BSL1		DO MORE

BSL3	LDA	SORT
	ANA	A
	RZ
	LHLD	NAMTLEN
	MOV	B,H
	MOV	C,L
	LXI	D,FB.NAML
	CALL	$DU66		(HL) = # OF FILE NAMES
	MOV	A,H
	ANA	A
	JNZ	IERR2
	SHLD	BSLN

*	MAKE SURE SORTAB IS 2 BYTES + A NULL & HAS ONLY 0,1,2 OR 3 IN IT

	LXI	H,SORTAB	1 = NAME FIELD
	MOV	A,M		2 = DEVICE FIELD (FAKED SO IT WORKS)
	CPI	4		3 = DEVICE FIELD
	JNC	SW.ERR
	INX	H
	MOV	A,M
	CPI	4
	JNC	SW.ERR
	INX	H
	MVI	M,0		FORCE FINAL NULL

	LDA	REVERSE 	(A)=0 IF ASCEND. (A)=3 IF DESCEND.
	LXI	H,$SORT
	CALL	$DADA
	SHLD	CALSRT

	CALL	$SORT
CALSRT	EQU	*-2
	DW	NAMTAB
	DW	FB.NAML
BSLN	DW	*-*
	DW	BSLFLD
	DW	SORTAB

	RET

BSLA	DB	0		<>0 IF TO CHECK FOR *.*

BSLFLD	DB	4,12	'N'	NAME & EXT	FIELD #1
	DB	0,4	'E'	TREAT AS DEV:	FIELD #2
	DB	0,4	'D'	DEV:		FIELD #3

	SPACE	4,10
**	CQF - Check Query Flag
*
*	CQF checks the query flag, and if it is set, asks
*	the user if the file is to be transfered by typing
*	the filename followed by a question mark.  If the
*	response begins with a 'Y' the file is transfered,
*	else, it is to be ignored.
*
*	ENTRY:	PIO.XXX = File Specification
*
*	EXIT:	PSW	= 'Z'  if     to Copy
*			  'NZ' if NOT to Copy
*
*	USES:	ALL

CQF	LDA	QUERY
	ANA	A
	RZ			NO Query, so transfer file
	CPI	'N'
	JE	CQFN

	CALL	CQF.
	PUSH	PSW
	CALL	$CRLF
	POP	PSW
	RET

CQF.	CALL	TFNS		Type the file name padded with spaces
	CALL	$TYPTX
	DB	' ?',' '+200Q
	SCALL	.CLRCO		Clear the console

	XRA	A		A = I.CSLMD
	MVI	B,CSL.CHR
	MVI	C,CSL.ECH+CSL.CHR
	SCALL	.CONSL		Set CHAR/ECHO

CQFX	SCALL	.SCIN
	JC	CQFX
	CALL	$MCU
	CPI	'Y'
	RE			Transfer this file
	CPI	'N'
	JE	CQFN
	CPI	'*'		Special marker ?
	JNE	CQF1		Oops
CQFX.	SCALL	.SCIN		Yes, get Y or N
	JC	CQFX.
	CALL	$MCU
	CPI	'Y'
	JE	CQFY
	CPI	'N'
	JNE	CQF1
	STA	QUERY		Don't transfer any of the rest either
CQFN	ORI	1		'NZ' => DON'T transfer this file
	RET

CQFY	XRA	A		Set 'Z'
	STA	QUERY		Transfer all of the rest also
	RET

CQF1	CALL	$TYPTX		Illegal Character Entered
	DB	BELL,'? (Y)es (N)o (*Y) (*N)',ENL
	JMP	CQF.
	SPACE	4,10
**	CCW - CHECK FOR COMPLETE WILDCARD.
*
*	CCW IS CALLED WITH A NAME CRACKED INTO PIO.XXX, TO SEE IF
*	IT IS A *.* SPECIFICATION.
*
*	IF SO, CCW ASKS,
*
*	!?! DELETE ALL FILES ON DEV: (Y/N/Q)?
*
*	THE USER REPLY IS ACCEPTED AND DECODED.
*
*	ENTRY	NONE
*	EXIT	'C' CLEAR IF NOT *.*, OR 'Y' OR 'Q' REPLIED
*		'C' SET IF *.* AND NOT 'Y'
*	USES	A,F,B,H,L

CCW	LXI	H,PIO.DIR+DIR.NAM
	MVI	B,8+3
	MVI	A,200Q
CCW1	ANA	M		SEE IF ALL HAVE 200Q BIT SET
	INX	H
	DCR	B
	JNZ	CCW1
	ANA	A
	RP			NOT *.*

*	IS *.*

	CALL	$TYPTX
	DB	BELL,'!?! DELETE ALL FILES ON',' '+200Q
	LXI	H,PIO.DEV
	MVI	A,3
	CALL	$TYPCC		TYPE DEVICE NAME
	CALL	$TYPTX
	DB	': (Y/N/Q)?',' '+200Q
	LXI	H,DESTBUF
	CALL	$RTL.		READ REPLY
	LDA	DESTBUF
	CPI	'Y'
	RE			IS OK
	CPI	'Q'
	JNZ	CCW2
	MVI	A,1
	STA	QUERY		SET QUERY MODE
	RET
CCW2	STC
	MVI	A,PEC.IUW	FLAG ILLEGAL USE OF WILDCARD
	RET			FORGET IT
	SPACE	4,10
**	CFE - CHECK FILE ELIGIBILITY.
*
*	CFE CHECKS TO SEE IF A WILDCARD-SELECTED FILE IS ELIGIBLE FOR
*	PROCESSING. IF THE FILE IS FLAGGED SYSTEM, AND /S IS NOT SPECIFIED,
*	THE FILE IS NOT ELIGIBLE. IF /FL OR /NOF OR /US OR /NOU OR /CUR
*	OR /BEF OR /AFT FAILS, THE FILE IS NOT ELIGIBLE.
*
*	ENTRY	(HL) = DIRECTORY ENTRY POINTER
*	EXIT	'Z' SET IF ELIGIBLE
*	USES	A,F

CFE	PUSH	D
	PUSH	H
	MVI	A,DIR.NOA
	CALL	$DADA.
	MOV	A,M		(A) = A/C
	STA	CFEA		SAVE ACCESS COUNT

	ERRNZ	DIR.FLG-DIR.NOA-1
	INX	H
	MOV	A,M		(A) = FLAG
	STA	CFEF		SAVE FILE FLAGS

	ERRNZ	DIR.USR-DIR.FLG-1
	INX	H

	IF	USER
	MOV	A,M		(A) = USER
	ORI	200Q		FORCE USER AREA 0
	STA	CFEU		SAVE FILE USER AREAS
	ENDIF

	ERRNZ	DIR.CRD-DIR.USR-4
	INX	H
	INX	H
	INX	H
	INX	H
	MOV	E,M
	INX	H
	MOV	D,M

	LDA	ACCESS
	ORA	A
	JZ	CFE00
	INX	H
	MOV	E,M
	INX	H
	MOV	D,M
CFE00	XCHG
	SHLD	TDATE

CFE0	LDA	FLAG		CHECK /FL:
	ORA	A
	JZ	CFE1
	LXI	H,FLAG
	LDA	CFEF
	ANA	M
	CMP	M
	JNZ	CFE.N

CFE1	LDA	NOFLAG		CHECK /NOF:
	ORA	A
	JZ	CFE2
	LXI	H,NOFLAG
	LDA	CFEF
	ANA	M
	JNZ	CFE.N

CFE2	EQU	*

	IF	USER
	LDA	USER		CHECK /US:
	ORA	A
	JZ	CFE3
	LXI	H,USER
	LDA	CFEU
	ANA	M
	CMP	M
	JNZ	CFE.N

CFE3	LDA	NOUSER		CHECK /NOU:
	ORA	A
	JZ	CFE4
	LXI	H,NOUSER
	LDA	CFEU
	ANA	M
	JNZ	CFE.N
	ENDIF

CFE4	LDA	BEFORE		CHECK /BEF:
	ORA	A
	JZ	CFE5
	LHLD	TDATE
	XCHG			(DE) = FILE'S DATE
	LHLD	DATEB		(HL) = WORKING DATE
	CALL	CPDEHL
	JZ	CFE.N
	JC	CFE.N

CFE5	LDA	CURREN		CHECK /CUR:
	ORA	A
	JZ	CFE6
	LHLD	TDATE
	XCHG			(DE) = FILE'S DATE
	LHLD	DATEC		(HL) = WORKING DATE
	CALL	$CDEHL
	JNZ	CFE.N

CFE6	LDA	AFTER		CHECK /AFT:
	ORA	A
	JZ	CFE7
	LHLD	TDATE
	XCHG			(DE) = FILE'S DATE
	LHLD	DATEA		(HL) = WORKING DATE
	CALL	CPDEHL
	JZ	CFE.N
	JNC	CFE.N

CFE7	LDA	COUNT		CHECK /COU:
	ORA	A
	JZ	CFE8
	MOV	E,A
	LDA	CFEA
	CMP	E		OK, if accesses >= COUNT #
	JC	CFE.N

CFE8	LDA	NOCOUNT 	CHECK /NOC:
	ORA	A
	JZ	CFE9
	MOV	E,A
	LDA	CFEA
	CMP	E		OK, if accesses < COUNT #
	JNC	CFE.N
	JZ	CFE.N

CFE9	POP	H		CHECK /S
	POP	D
	LDA	CFEF
	ANI	DIF.SYS
	RZ			ELIGIBLE
	LDA	SYSTEM		CHECK /S FLAG
	DCR	A
	RET

CFEA	DB	0		ACCESS COUNT BYTE
CFEF	DB	0		FLAG BYTE
	IF	USER
CFEU	DB	0		USER BYTE
	ENDIF
TDATE	DW	0

CFE.N	POP	H		IS NOT ELIGIBLE
	POP	D
	ORI	1		FORCE 'NZ'
	RET
	SPACE	4,10
**	CFS - COMPUTE FILE SIZE
*
*	CFS COMPUTES THE SIZE OF A FILE. THE DEVICE'S GRT MUST BE IN
*	THE 'GRT' BUFFER.
*
*	ENTRY	(A) = FIRST GROUP NUMBER
*	EXIT	(DE) = SIZE
*	USES	ALL

CFS	LHLD	LSTE
CFS.	LXI	D,0
CFS1	ANA	A
	RZ			ALL DONE
	MOV	L,A
	MOV	A,M		(A) = NEXT GRT
	INX	D
	JMP	CFS1		TRY AGAIN
	SPACE	4,10
**	CTS	-  CHECK TARGET FILE SPECIFICATION
*
*	CTS CHECKS FOR A TARGET FILE SPECIFICATION
*
*
*	ENTRY	NONE
*
*	EXIT	(PSW)	= 'Z' SET IF NO TARGET FILE
*			= 'Z' CLEAR IF    TARGET FILE
*			   (A)  = PEC.TFI ERROR CODE
*
*	USES	(PSW),(HL)

CTS	CALL	LSN		(HL) = ADDRESS OF FIRST SOURCE NAME
	LXI	D,-LINE
	DAD	D		(HL) == 0 IF NO '=' IN COMMAND LINE
	MOV	A,L
	ORA	H
	RZ			NO TARGET FILE
	MVI	A,PEC.TFI	TARGET FILE ILLEGAL
	RET			TARGET FILE SPECIFIED
	SPACE	4,10
**	CWM - CHECK WILDCARD MATCH.
*
*	CWM CHECKS TO SEE IF A WILDCARDED FIELD MATCHES A NON-WILDCARDED
*	FIELD.
*
*	ENTRY	(DE) = ADDRESS OF WC NAME
*		(HL) = ADDRESS OF NON/WC NAME
*		(B) = NUMBER OF CHARACTERS TO CHECK
*	EXIT	'Z' SET IF MATCH
*		 (HL) = (HL)+(B)
*		 (DE) = (DE)+(B)
*		'Z' CLEAR IF NO MATCH
*	USES	A,F,B,D,E,H,L

CWM	LDAX	D
	ANA	A
	JM	CWM1		IS MATCH
	CMP	M
	RNE			NO MATCH
CWM1	INX	D
	INX	H		ADVANCE ADDRESSES
	DCR	B
	JNZ	CWM		GO FOR MORE
	RET			GOT MATCH
	SPACE	4,10
**	DDF - DECODE DESTINATION FILE.
*
*	DDF DECODES THE DESTINATION FILE NAME FROM THE COMMAND LINE.
*
*	IF NO DESTINATION NAME IS SPECIFIED, IT DEFAULTS TO
*		TT:PIPDEST.JGL
*
*	IF THE DESTINATION IS SPECIFIED AS A DEVICE NAME ONLY, IT
*	IS EXPANDED TO DEV:????????.???
*
*	ENTRY	NONE
*	EXIT	'C' CLEAR IF OK
*		 (A) = 0 IF NAME HAS WILDCARDS
*		 (A) = 1 IF NO WILDCARD USED
*		 DESTFB+FB.NAM CONTAINS A COMPLETE DESTINATION FILE NAME
*		 (HL) = COMMAND LINE POINTER UDPATED
*		'C' SET IF ERROR
*		 (A) = CODE
*	USES	ALL

DDF	LXI	D,LINE
	MOV	H,D
	MOV	L,E		(HL) = COMMAND POINTER
DDF1	LDAX	D
	INX	D
	CPI	'='
	JE	DDF2		HAVE A SOURCE FILE
	ANA	A
	JNZ	DDF1		MORE TO CHECK
DDF1.0	LXI	H,DDFA		USE DEFAULT

*	(HL) = ADDRESS FOR NAME

DDF2	LXI	D,DEFALT
	CALL	CAD		CONVERT ASCII NAME TO DIRECTORY FORMAT
	RC			ERROR
	JZ	DDF1.0		NO FILE NAME SPECIFIED, USE DEFAULT
	MOV	A,M
	CPI	'='
	MVI	A,PEC.IDF	ASSUME ILLEGAL DESTINATION FORMAT
	STC
	RNE			MUST HAVE '='

*	check for device name without file name.

	lxi	h,pio.dir+DIR.NAM
	lda	pio.dir+DIR.EXT
	ora	m
	jnz	ddf4			; have name and/or extension

*	Check it to see if it's a valid device. Non-directoried
*	devices will not be converted to the wild-card format.

	push	h			; save
	lhld	pio.dev 		; get device name
	xchg				;  in (de)
	scall	.gda			; (bc) = driver address
	jrc	ddf5			; yep, skip out.
	lxi	h,DEV.FLG		; offset to device flag
	dad	b			; get it
	mvi	a,DT.DD
	ana	m			; directory device?
	pop	h
	jrz	ddf4			; no, don't wild-card it.

*	have device only, make it the same as ????????.???

	mvi	b,8+3
ddf3	mvi	m,200Q
	inx	h
	dcr	b
	jrnz	ddf3

*	HAVE NAME DECODED. EXPAND INTO DESTFB+FB.NAM

DDF4	LXI	H,DESTFB+FB.NAM
	JMP	CDA		CONVERT DIRECTORY FORMAT TO ASCII FORMAT

*	abort

ddf5	pop	h			; clear stack
	ret

DDFA	DB	'TT:PIPDEST.JGL=',0
	SPACE	4,10
**	CAD - CONVERT ASCII FILE NAME INTO DIRECTORY FORMAT.
*
*	CAD CRACKS AN ALPHANUMERIC FILE DESCRIPTION, OF THE FORM
*
*	DEV:NAME.EXT
*
*	INTO THE PIO.XXX FIELDS.
*
*	THE DEFAULT BLOCK DETERMINES THE VALUES FOR THE DEVICE AND EXTENSION
*	FIELDS, IF THEY ARE UNSPECIFIED. IF *CAD* IS ENTERED
*	AT *CAD*, AN UNSPECIFIED NAME FIELD IS RETURNED AS ZERO BYTES.
*	IF ENTERED AT *CAD.*, AN UNSPECIFIED NAME FIELD IS
*	RETURNED AS 200Q (MATCH-ONE) BYTES.
*
*	ENTRY	(DE) = POINT TO DEFAULT BLOCK
*		(HL) = POINTER TO TEXT
*	EXIT	'C' SET IF ERROR
*		 (A) = ERROR CODE
*		'C' CLEAR IF OK
*		 (HL) = POINTS PAST FILE NAME
*		 'Z' SET IF NULL NAME
*		 'Z' CLEAR IF NON-NULL
*		  PIO.DIR.NAM = NAME
*		  PIO.DIR.EXT = EXTENSION
*		  PIO.DEV = DEVICE CODE
*		  PIO.UNI = UNIT NUMBER (ASCII DIGIT)
*	USES	ALL

CAD	XRA	A		SET TO NULLS
	JMP	CAD0

CAD.	MVI	A,200Q
CAD0	PUSH	H
	STA	CADA		SAVE DEFAULT VALUE

*	SET DEFAULTS IN PIO.xxx

	LXI	H,PIO.DEV
	LXI	B,3
	CALL	$MOVE		SET DEFALUT DEVICE
	LXI	B,3
	LXI	H,PIO.DIR+DIR.EXT
	CALL	$MOVE		SET DEFAULT EXTENSION
	POP	H
	CALL	$SOB		SKIP BLANKS
	MVI	B,0
	CPI	'?'
	JE	CAD1		IS '?'
	CPI	'*'
	JE	CAD1		IS '*'
	CPI	'.'
	JE	CAD1		IS '.'
	CPI	'A'
	JC	CAD4		NOT NAME
	CPI	'Z'+1
	JNC	CAD4		NOT NAME

*	HAVE ALPHA STRING. CRACK IT

CAD1	CALL	DNT		DECODE NEXT TOKEN
	JC	CAD5		ERROR
	CPI	':'
	JNE	CAD2		NOT DEVICE

*	HAVE EXPLICIT DEVICE

	INX	H		SKIP ':'
	MVI	A,3
	CMP	C
	JC	CAD5		TOO MANY CHARACTERS
	MVI	A,PIO.UNI-PIO.DEV-1
	CMP	C
	JNC	CAD5		Too Few characters

	MVI	A,'0'
	STA	PIO.UNI 	Assume Unit 0
	MVI	B,0		BC = Move Count
	PUSH	H		SAVE (HL)
	LXI	H,PIO.DEV
	CALL	$MOVE		SET EXPLICIT DEVICE
	POP	H
	CALL	DNT		DECODE NEXT TOKEN
	JC	CAD5		ERROR

*	DECODE NAME

CAD2	LXI	B,8		(BC) = COUNT
	PUSH	H		SAVE TEXT ADDR

*	SEE IF NAME IS UNSPECIFIED

	LXI	H,PIO.DIR+DIR.NAM
	PUSH	H		SAVE ADDRESS OF DIR.NAM
	CALL	$MOVE		MOVE IN NAME
	POP	H		(HL) = #PIO.DIR+DIR.NAM
	MOV	A,M
	ANA	A
	JNZ	CAD2.6		IS SPECIFIED
	LDA	CADA		(A) = FILL CHARACTER
	MVI	C,8		(C) = COUNT
CAD2.4	MOV	M,A
	INX	H
	DCR	C
	JNZ	CAD2.4
CAD2.6	POP	H
	MOV	A,M		(A) = DELIMITER
	CPI	'.'
	JNE	CAD3		NOT EXTENSION

*	HAVE EXPLICIT EXTENSION

	INX	H
	CALL	DNT
	JC	CAD5		ERROR
	MVI	A,3
	CMP	C
	JC	CAD5		TOO LONG
	LXI	B,3
	PUSH	H		SAVE TEXT POINTER
	LXI	H,PIO.DIR+DIR.EXT
	CALL	$MOVE		MOVE EXTENSION
	POP	H

*	DONE WITH NAME. MUST HAVE LEGIT DELIMITER

CAD3	MVI	B,1		(B) = NAME PRESENT FLAG

*	END OF NAME. EXIT
*	(B) = 0 IF NULL, (B) <> 0 IF NON-NULL

CAD4	CALL	$SOB		SKIP BLANKS
	CALL	$CFD		CHECK FILE NAME DELIMITER
	RC			ERROR
	MOV	A,B
	ANA	A		SET 'Z' IF NULL
	RET

*	ERROR

CAD5	MVI	A,EC.IFN	ILLEGAL FILE NAME
	STC
	RET

CADA	DB	0		FILL CHARACTER FOR OMITTED NAME FIELD
	SPACE	4,10
**	DNT - DECODE NEXT TOKEN.
*
*	DNT COPIES THE NEXT ALPHANUMERIC FIELD INTO A ZERO-FILLED WORK AREA.
*
*	ENTRY	(HL) = TEXT POINTER
*	EXIT	'C' SET IF ERROR
*		'C' CLEAR IF OK
*		(A) = DELIMTER CHARACTER
*		(HL) UPDATED TO DELIMITER CHARACTER
*		(DNTA) = STRING
*		(C) = LENGTH
*		(DE) = #DNTA
*	USES	ALL

DNT	LXI	D,DNTA
	MVI	C,9		(C) = SIZE OF DNTA
	MOV	B,C		(B) = MAX ALLOWED +1
	XRA	A
DNT1	STAX	D		ZERO BUFFER
	INX	D
	DCR	C
	JNZ	DNT1
	LXI	D,DNTA

*	COPY CHARACTERS

DNT2	MOV	A,M
	CPI	'?'
	MVI	A,200Q
	JE	DNT3		IS MATCHONE
	MOV	A,M
	CPI	'*'
	JE	DNT5		IS WILDCARD
	CPI	'0'
	JC	DNT4		NOT ALPHANUMERIC
	CPI	'9'+1
	JC	DNT3		NUMERIC
	CPI	'A'
	JC	DNT4		DELIMITER
	CPI	'Z'+1
	JNC	DNT4		DELIMITER

*	HAVE GOOD CHARACTER

DNT3	STAX	D		STORE CHAR
	INX	D
	INX	H
	INR	C		COUNT
	DCR	B		LIMIT DECREMENT
	JNZ	DNT2		NOT OVERFLOW

*	OVERFLOW

	STC			FLAG ERR
	RET

*	IS '*' WILDCARD

DNT5	MVI	A,200Q
	STAX	D
	INX	D
	DCR	B
	JNZ	DNT5		FILL WITH MATCH ONE
	INX	H		SKIP '*'

*	END OF STRING

DNT4	ANA	A		CLEAR 'C'
	LXI	D,DNTA		SET POINTER
	RET

DNTA	DS	9		WORK AREA
	SPACE	4,10
**	EBM - EXPAND BUFFER TO MAXIMUM.
*
*	EBM IS CALLED TO EXPAND THE BUFFER 'BUF' TO THE MAXIMUM SIZE.
*	WHICH DOES NOT REQUIRE THE OVERLAYING OF THE SYSTEM.
*
*	ENTRY	NONE
*	EXIT	(BUFSIZ) = BUFFER SIZE (MULTIPLE OF 256)
*	USES	ALL

EBM	LHLD	S.SYSM
	LXI	D,-6
	DAD	D		(HL) = NEW ADDRESS SOUGHT
	SCALL	.SETTOP
	JC	IERR1		INTERNAL ERROR 1
	LHLD	S.USRM
	XCHG
	LHLD	BUFPTR
	CALL	$CHL		(HL) = - BUFFER FWA
	DAD	D
	MVI	L,0
	SHLD	BUFSIZ
	MVI	A,BUFMINL/256-1
	CMP	H
	RC			IF OK
	MVI	A,EC.NEM
	JMP	ERROR		NOT ENOUGH MEMORY
	SPACE	4,10
**	CDA - CONVERT DIRECTORY FORMAT TO ASCII.
*
*	CDA COPIES A DIRECTORY ENTRY FROM PIO.XXX TO A TARGET FIELD.
*	THE DEVICE SPECIFICATION (IN PIO.DEV AND PIO.UNI) IS ALSO ENCODED.
*	THE TARGET FIELD IS LEFT IN THE FORM:
*
*	DEV:NAME.XXX <00>
*
*	ENTRY	(HL) = FWA NAME FIELD
*	EXIT	(A) = 0, HAVE WILDCARD
*		    = 1, NO WILDCARDS USED
*		'C' CLEAR
*	USES	ALL

CDA	LXI	B,3*256		(B) = CHARACTER COUNT, (C) = WILDCARD FLAG
	LXI	D,PIO.DEV
	CALL	CDA5		COPY IT
	MVI	M,':'
	INX	H
	MVI	B,8
	LXI	D,PIO.DIR+DIR.NAM
	CALL	CDA5		COPY IT
	MVI	M,'.'
	INX	H
	MVI	B,3
	ERRNZ	DIR.EXT-DIR.NAM-8
	CALL	CDA5		COPY IT
	MVI	M,0		FLAG END OF NAME
	MOV	A,C		(A) (BIT 7) = 1 IF WILDCARDS
	RLC
	CMA
	ANI	1		=0 IF WILDCARD
	RET
	SPACE	2,10
**	CDA5 - CONVERT DIRECTORY FIELD TO ASCII.
*
*	ZEROS ARE IGNORED, 200Q WILDCARDS ARE MAPPED TO '?'
*
*	ENTRY	(DE) = FROM
*		(HL) = T0
*		(B) = COUNT
*		(C) = ORA ACCUMULATOR
*	EXIT	(DE) ADVANCED
* 		(HL) = (HL)+(B)
*		(C) = (C) .OR. (FROM CHARACTERS PROCESSED)
*	USES	ALL

CDA5	LDAX	D		(A) = CHARACTER
	ORA	C
	MOV	C,A
	LDAX	D
	INX	D
	ANA	A
	JZ	CDA7		IS 00
	JP	CDA6		NOT 200Q
	MVI	A,'?'
CDA6	MOV	M,A
	INX	H		INCREMENT TO
CDA7	DCR	B
	JNZ	CDA5		IF MORE TO GO
	RET
	SPACE	4,10
**	EWS - EXPAND WILDCARD SPECIFICATION.
*
*	DWS ENTERS THE FILE NAME IN PIO.XXX INTO THE MANAGED TABLE
*	NAMTAB. IF THE FILE NAME CONTAINS WILDCARDS, THE DIRECTORY
*	IS READ FOR ELIGIBLE FILES.
*
*	ENTRY	PIO.XXX = FILE NAME
*	EXIT	'C' CLEAR IF OK
*		'C' SET IF ERROR
*	USES	ALL

EWS	CALL	AEN		TRY TO ENTER IT
	RNC			NO WILDCARDS, AM DONE

*	IS WILDCARD. LOOK UP DEVICE TYPE

	LHLD	NAMTLEN
	LXI	D,NAMTAB-FB.NAML
	DAD	D		(HL) = ADDRESS OF LAST ENTRY
	CALL	CAD		CONVERT ASCII NAME TO DIRECTORY FORMAT
	RC			ERROR
	LHLD	NAMTLEN
	LXI	D,-FB.NAML
	DAD	D
	SHLD	NAMTLEN		REMOVE WILDCARD FROM TABLE
	CALL	$MOVEL
	DW	3,PIO.DEV,DIRNAM	SET DIRECTORY NAME IN XXX:DIRECT.SYS
	CALL	$MOVEL
	DW	8+3,PIO.DIR+DIR.NAM,EWSC	SAVE WILDCARD PATTERN
	LXI	B,EWSB
	LXI	H,DIRNAM
	SCALL	.DECODE 	GET INFORMATION ABOUT DEVICE
	RC			ERROR
	LDA	EWSB		SEE IF A DIRECTORY DEVICE
	ANI	DT.DD
	MVI	A,EC.DNS		ASSUME DEVICE NOT SUITABLE
	STC
	RZ			ERROR

*	IS DIRECTORY DEVICE. OPEN DIRECTORY

	LXI	H,DIRNAM
	MVI	A,CN.DIR
	SCALL	.OPENR
	MVI	A,PEC.DF
	RC			DEVICE FORMAT FAILURE

*	READ DIRECTORY ENTRYS FOR MATCH

EWS1	CALL	GDWP		DE = DIRECTORY WORKSPACE PTR
	LXI	B,512
	MVI	A,CN.DIR
	PUSH	D		SAVE ADDRESS
	SCALL	.READ		READ BLOCK
	POP	H		(HL) = DIRECTORY ADDRESS
	JC	EWS7		ALL DONE

*	LOOK AT DIRECTORY BLOCK FOR MATCHES

	PUSH	H
	CALL	GDWP.
	CALL	$INDLB
	DW	DIS.ENL 	A  = DIRECTORY ENTRY LENGTH
	POP	H

	MOV	C,A		(C) = LENGTH

*	CHECK NEXT ENTRY

EWS3	MOV	A,M		(A) = 1ST CHAR THIS ENTRY
	ANA	A
	JZ	EWS1		END OF BLOCK
	ERRNZ	DF.EMP-377Q
	INR	A
	JZ	EWS6		ENTRY EMPTY
	ERRNZ	DF.CLR-376Q
	INR	A
	JZ	EWS7		END OF LIST
	CALL	CFE		CHECK FOR FILE ELIGIBILITY
	JNZ	EWS6		NOT TO PROCESS
	PUSH	H
	LXI	D,EWSC
	MVI	B,8+3
	CALL	CWM		CHECK WILDCARD MATCH

*	KLUDGE FOR NEGATE STATE OF 'Z' FLAG IF /- SPECIFIED

	PUSH	PSW		FLIP-FLOP ON /-
	LDA	NEGATE		     /
	XTHL			    /
	XRA	L		IF NOT /- 'Z' STATE IS UNCHANGED
	MOV	L,A		  /
	XTHL			 /
	POP	PSW		/

	JNZ	EWS4		NO MATCH

*	HAVE MATCH. ADD TO LIST

	POP	D		(DE) = FROM
	PUSH	D
	PUSH	B		SAVE (C)
	LXI	B,8+3
	LXI	H,PIO.DIR+DIR.NAM
	CALL	$MOVE
	CALL	AEN		ADD TO TABLE
	POP	B		RESTORE (C)

*	LOOKUP NEXT ENTRY

EWS4	POP	H
EWS6	MVI	B,0
	DAD	B		POINT TO NEXT
	JMP	EWS3

*	ALL DONE. CLOSE DIRECTORY FILE

EWS7	MVI	A,CN.DIR
	SCALL	.CLOSE
	RET

EWSA	DB	'SY0',200Q,200Q,200Q
	SPACE	4,10
**	GDWP	-  GET DIRECTORY WORKSPACE POINTER
*
*	GDWP GETS THE DIRECTORY WORKSPACE POINTER
*
*	ENTRY:	NONE
*
*	EXIT:	DE	= DIRECTORY WORKSPACE POINTER
*
*	USES:	DE

GDWP	XCHG
	CALL	GDWP.		HL = DIRECTORY WORKSPACE POINTER
	XCHG
	RET

GDWP.	LHLD	S.SCR		HL = SYSTEM SCRATCH
	RET
	SPACE	4,10
**	INA - INCREASE NAMTAB ALLOCATION.
*
*	INA IS CALLED TO INCREASE THE NAMTAB ALLOCATION. THE
*	BUFFER AREA IS MOVED UP TO MAKE ROOM.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	A,F,H,L

INA	LXI	H,NAMTMAX+1
	INR	M		INCREMENT LENGTH
	LXI	H,BUFPTR+1
	INR	M		MOVE BUFFER
	LHLD	BUFSIZ
	MOV	A,H
	ORA	L
	MVI	A,EC.NEM	FLAG OUT OF MEMORY IF BUFFER NOT EMPTY
	JNZ	ERROR
	PUSH	B
	PUSH	D
	CALL	SBE		NOTIFY SYSTEM
	POP	D
	POP	B
	RET
	SPACE	4,10
**	LSN - LOCATE SOURCE NAME
*
*	LSN SCANS THE COMMAND LINE FOR THE FIRST SOURCE FILE NAME.
*
*	ENTRY	NONE
*	EXIT	(HL) = 1ST FILE NAME FWA
*	USES	A,F,H,L

LSN	LXI	H,LINE
LSN1	MOV	A,M
	INX	H
	CPI	'='
	RE			GOT IT
	ANA	A
	JNZ	LSN1		MORE LINE
	LXI	H,LINE		THERE WAS NO '='
	RET
	SPACE	4,10
**	MWN - MERGE WILDCARD NAMES.
*
*	MWN MERGES A COMPLETELY SPECIFIED FILENAME WITH A WILDCARDED COMPLETELY
*	SPECIFIED FILE NAME.
*
*	BOTH FILE NAMES SHOULD HAVE THE SAME DEVICE SPECIFICATION.
*
*	FILE NAME FORMAT:
*
*	DEV:NAMEXXXX.EXT 00
*
*	ENTRY	(BC) = ADDRESS OF WILDCARDED ASCII NAME
*		(DE) = ADDRESS OF NON-WC ASCII NAME
*		(HL) = ADDRESS FOR RESULTANT ASCII NAME
*	EXIT	NONE
*	USES	ALL

MWN	PUSH	H		SAVE TARGET ADDRESS
	PUSH	B		SAVE WC PATTERN
	XCHG			(HL) = MASTER NAME
	CALL	CAD		CONVERT TO DIRECTORY FORMAT
	CALL	$MOVEL
	DW	8+3,PIO.DIR,MWNA	(MWNA) = DECODED MASTER
	POP	H		(HL) = WC PATTERN
	CALL	CAD		(PIO.DIR) = WC PATTERN
	LXI	D,MWNA		(DE) = MASTER PATTERN
	LXI	H,PIO.DIR	(DE) = WC PATTERN ADDRESS
	MVI	C,8+3		MERGE NAME AND EXTENSION

*	MERGE NAMES

MWN1	MOV	A,M		(A) = WC PATTERN
	ANA	A
	JP	MWN2		USE THIS
	LDAX	D		IS MATCH CHARACTER, USE MASTER INSTEAD
MWN2	MOV	M,A		STORE CHARACTER
	INX	D
	INX	H
	DCR	C
	JNZ	MWN1		MERGE TILL DONE
	POP	H		(HL) = TARGET ADDRESS
	JMP	CDA		CONVERT DIRECTORY FORMAT TO ASCII
	SPACE	4,10
**	REN - REMOVE ENTRY FROM *NAMTAB*
*
*	REN REMOVES THE FIRST 'FB.NAML' BYTES FROM NAMTAB.
*
*	THE AMOUNT (FB.NAML) IS REMOVED FROM THE SIZE OF THE TABLE. THE
*	TABLE IS NOT CHECKED FOR UNDERFLOW, THE CALLER MUST GUARANTEE THE
*	PRESENSE OF AT LEAST FB.NAML BYTES IN NAMTAB.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL

REN	LHLD	NAMTLEN
	LXI	D,-FB.NAML
	DAD	D		REMOVE COUNT FROM LEN
	SHLD	NAMTLEN
	MOV	B,H
	MOV	C,L		(BC) = REMAINING LENGTH
	LXI	D,NAMTAB+FB.NAML	(DE) = START OF 2ND ENTRY
	LXI	H,NAMTAB
	JMP	$MOVE		MOVE DOWN AND RETURN
	SPACE	4,10
**	SBE - SET BUFFER EMPTY.
*
*	THE SYSTEM IS NOTIFIED.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	ALL

SBE	LXI	H,0
	SHLD	BUFSIZ
	LHLD	BUFPTR		(HL) = BUFFER FWA (AND LWA!)
	INX	H
	INX	H
	SCALL	.SETTOP
	RNC			OK
	JMP	ERROR		NOT ENOUGH ROOM
	SPACE	4,10
**	SDD - SET DEFAULT DEFAULT.
*
*	SDD IS CALLED TO SETUP THE CURRENT DEFAULT DEVICE
*	AND EXTENSION TO 'SY0' AND <NULL>, RESPECTIVELY.
*
*	ENTRY	NONE
*	EXIT	NONE
*	USES	NONE

SDD	CALL	$SAVALL
	CALL	$MOVEL
	DW	6,SDDA,DEFALT	SET DEFAULT DEFAULT
	JMP	$RSTALL		RESTORE AND RETURN

SDDA	DB	'SY0',0,0,0	DEFAULT DEFAULT VALUES
	SPACE	4,10
**	SFS - SKIP FILE SEPERATOR.
*
*	SFS IS CALLED TO SKIP OVER THE CHARACTERS SEPERATING ONE
*	FILE NAME FROM ANOTHER ON THE LINE. THE FILES MAY BE SEPERATED
*	BY BLANKS OR A COMMA ALONE, OR BY BLANKS WITH A COMMA. THE
*	SYNTAX IS
*
*	<BLANKS> <,> <BLANKS>
*
*	ONE, TWO OR ALL THREE FIELDS MAY BE PRESENT.
*
*	ENTRY	(HL) = POINT TO START OF SEP FIELD
*	EXIT	(HL) ADVANCED PAST SEPERATOR FIELD
*	USES	A,F,H,L

SFS	CALL	$SOB		SKIP BLANKS
	CPI	','
	JNE	SFS1		NOT ,
	INX	H		SKIP ,
SFS1	JMP	$SOB		GET ANY MORE BLANKS AND EXIT
	SPACE	4,10
**	SND - SET NEW DEFAULTS.
*
*	SND IS CALLED TO SET A NEW DEFAULT DEVICE AND EXTENSION
*	IN THE 'DEFALT' AREA.
*
*	ENTRY	PIO.DEV = DEVICE CODE
*		PIO.UNI = UNIT #
*		PIO.DIR+DIR.EXT = EXTENSION
*	EXIT	NONE
*	USES	NONE

SND	CALL	$SAVALL		SAVE REGS
	ERRNZ	PIO.UNI-PIO.DEV-2
	CALL	$MOVEL
	DW	3
	DW	PIO.DEV
	DW	DEFALT
	CALL	$MOVEL
	DW	3
	DW	PIO.DIR+DIR.EXT
	DW	DEFALT+3
	JMP	$RSTALL		RETURN
